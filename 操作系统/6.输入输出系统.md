## I/O系统的功能、模型和接口

#### I/O系统的基本功能

第一、第二方面的功能是为了**方便用户使用I/O设备**；第三、第四方面的功能是用于**提高CPU和I/O设备的利用率**。
第五、第六方面的功能是为用户**在共享设备时提供方便**，**以保证系统能有条不紊的 运行**，当系统发生错误时能**及时发现错误**，甚至于能自动修正错误。

**1.隐藏物理设备的细节**
	I/O系统必须通过对设备加以适当的抽象，以隐藏掉物理设备的实现细节，仅向上层进程提供少量的，抽象的读/写命令

**2.与设备的无关性**
	用户不仅可以使用抽象的I/O命令，还可以**使用抽象的逻辑设备名来使用设备**。允许在不需要将整个操作系统进行重新编译的情况下，**增添新的设备驱动程序**，以方便新的I/O设备的安装。

**3.提高处理机和I/O设备的利用率**
	一方面要求**处理机能够快速响应用户的I/O请求**，另一方面**减少在每一个I/O设备运行时处理机的干预时间**。

**4.对I/O设备进行控制**
==四种控制方式：==
	①**采用轮询的可编程I/O方式**
	②**采用中断的可编程I/O方式**
	③**直接存储器访问方式**
	④**I/O通道方式**

**5.确保对设备的正确共享**
①独占设备 ②共享设备

**6.错误处理**
	临时性错误：通过重试操作来纠正。
	持久性错误：向上层报告。

#### I/O系统的层次结构和模型

==**1.I/O软件的层次结构**==
	①**用户层I/O软件**
	②**设备独立性软件**
	③**设备驱动程序**
	④**中断处理程序**

**2.I/O系统中各种模块之间的层次视图**
**I/O系统的上、下接口**
	I/O系统接口
	软件/硬件(RW/HW)接口

**I/O系统的分层**
	中断处理程序：与硬件交互。
	设备驱动程序：**进程和设备控制器**之间的通信程序。
	设备独立性软件：**I/O软件独立于具体使用的物理设备**。

**==i/o系统接口 设备独立性软件 设备驱动程序 中断处理程序 RW/HW接口 设备控制器==** （顺序）

#### I/O系统接口

**1.块设备接口**
	块设备(磁盘设备的I/O常采用DMA方式)，隐藏了磁盘的二维结构，将抽象命令映射为底层操作。

**2.流设备接口**
	字符设备，get和put操作，in_control指令

**3.网络通信接口**
	计算机能通过网络与网络上的其他计算机进行通信或上网浏览。

## I/O设备和设备控制器

#### I/O设备

**1.I//O设备的类型**
	①按使用特性分类：存储设备，I/O设备
	②按传输速率分类：低速设备，中速设备，高速设备。

**2.设备与控制器之间的接口**
	①**数据信号线**②**控制信号线**③**状态信号线**

#### 设备控制器

控制**一个或多个I/O设备**，以实现**/O设备和计算机之间的数据交换**。

**1.设备控制器的基本功能**
	①接收和识别**命令**②**数据交换**③标识和报告设备的**状态**④**地址识别**⑤**数据缓冲区**⑥**差错控制**

**2.设备控制器的组成**
	①**设备控制器与处理机的接口**：数据线，地址线，控制线，数据线与(数据寄存器和状态寄存器相连)
	②**设备控制器和设备的接口**：存在三种类型的信号，数据、控制和状态。
	③**I/O逻辑**：实现对设备的控制。**通过一组控制线与处理机交互**，处理机**利用该逻辑先控制器发送I/O命令**。

#### 内存映像I/O

**1.利用特点的I/O指令**

**2.内存映像I/O**
	将内存单元地址和设备控制器中的寄存器统一编制为k。当k大等于n时，则是控制器的寄存器地址。
	内存I/O映像方式同一了对内存和对控制器的访问方式，简化了I/O编程。

#### I/O通道

**1.I/O通道设备的引入**
	在CPU和设备控制器之间又增加了I/O通道。其目的是：**建立独立的I/O操作**，将一些原来**由CPU处理的I/O任务转由通道来承担**，从而把CPU从繁杂的I/O任务中解脱出来。**通道与CPU共享内存**。

**2.通道类型**
	①字节多路通道
	②数组选择通道
	③数组多路通道

**3.“瓶颈”问题**
	通道价格昂贵，致使机器中所设置的通道数量势必较少，导致I/O瓶颈。解决这问题的有效方法，便是**增加设备与主机间的通路而不增加通道**。

## 中断机构和中断处理程序

#### ==中断简介==

**1.中断和陷入**
	**中断：**中断是指CPU对I/O设备发来的中断信号的一种响应，又称外中断。
	**陷入：**由CPU内部时间所引起的中断，这类中断称为**内中断**或**陷入**。

**2.中断向量表和中断优先级**
	①**中断向量表：**中断向量表标识中断向量号对应的中断程序的入口地址，I/O设备发来中断请求信号时，中断控制器确定该请求的终端号，根据该**中断号去查找中断向量表**，得到中断程序的入口地址。
	②**中断优先级：**经常会有多个中断信号源，每个**中断源对服务要求的紧急程度并不相同**，因此设置了不同的优先级。

**3.对多中断源的处理方式**  2个
	①屏蔽(禁止)中断
	②嵌套中断：允许中断嵌套，允许中断抢占。

#### 中断处理程序

中断处理程序的**处理过程可分成以下几个步骤**：
	①**测定**是否有未响应的**中断信号**。	
	②**保护**被中断进程的**CPU环境**。
	③**转入相应的设备处理程序**。
	④**中断处理**。
	⑤**恢复**CPU的**现场并退出中断**。

## 设备驱动程序

#### 设备驱动程序概述

**1.设备驱动程序概述**
	①**接收由与设备无关的软件发来的命令和参数**，并将命令中的抽象要求**转换**为与设备相关的低层操作序列。
	②**检查**用户I/O请求的**合法性**。③**发出I/O命令**。④及时**响应**由设备控制器发来的**请求中断并处理**。

**2.设备驱动程序的特点**
	①驱动程序是实现在与**设备无关的软件和设别控制器之间的通信和转换**的程序。
	②驱动程序与**设备控制器以及I/O设备的硬件**特性紧密相关。
	③驱动程序与**I/O设备所采用的I/O控制方式**紧密相关 采用I/O控制方式**中断驱动和DMA方式**。
	④由于驱动程序与**硬件**紧密相关。
	⑤驱动充许允许**可重入**。	

**3.设备处理方式**
	①为**每一类设备设置一个进程**，专门用于执行这类设备的I/O操作。
	②在**整个系统中设置一个I/O进程**，专门用于执行系统中所有各类设备的I/O操作。
	③不设置专门的设备处理进程，只为各类设备设置相应的**设备驱动层序**，**供用户或系统进程调用**。目前这种方式很多。

#### 设备驱动程序的处理过程

① 将**抽象要求转换为具体要求**。② 对服务**请求**进行**校验**。③ **检查设备**的状态 ④ **传送必要的参数**。⑤ **启动I/O设备。**

#### 对I/O设备的控制方式

**1.使用轮询的可编程I/O方式**
	对每个设备轮询若存在请求，则进行相应程序执行。

**2.使用中断的可编程I/O方式**
	等待中断在进行相应程序。

**==3.直接存储器访问方式==**
**特点：**
	①**数据传输的基本单位是数据块**②传送的数据是**从设备直接送入内存**③仅在**传送一个或多个数据块的开始和结束时，才需CPU干预**。

**DMA控制器的组成：**
	**三部分组成**：主机与DMA控制器的接口；DMA控制器与块设备的接口；I/O控制逻辑。
	DMA控制器的**四类寄存器**：
		**命令/状态寄存器CR**，**内存地址**寄存器MAR，**数据**寄存器DR，**数据计数**器DC。

**DMA工作过程：**
	设置MAR，DC，启动DMA，传送数据，增加MAR减少DC，DC = 0请求中断，否则继续。

**==4.I/O通道控制方式==**
**引入：**把CPU的干预减少为一组数据块的读(或写) 及有关的控制和管理为单位的干预。
**通道程序：**
	①**操作码**②**内存地址**③**计数**④**通道程序结束位P**⑤**记录结束标志R(R = 0表明本条指令和下条指令所处理的数据是同属一个记录)**

## 与设备无关的I/O软件

#### 基本概念

**1.以物理设备名使用设备**
	这使应用程序与系统中的物理设备直接相关。在进程请求物理设备时，若已分配给其他进程，尽管还有几台其它的相同设备空闲，但系统只能根据设备的物理名来分配，无法将另外相同的设备分配给它。当物理设备被更新时，程序再也无法在该系统上运行。

**2.引入了逻辑设备名**
	为了实现与设备的无关性而引入了逻辑设备和物理设备两个概念。**逻辑设备时抽象的设备名**，只说明要使用某类设备，并不指明具体是哪个设备。与设备的无关软件还可以实现**I/O重定向**。

**3.逻辑设备名称到物理设备名称的转换**
	逻辑设备方便用户使用，单系统只识别物理设备名称，因此在实际执行时，还需使用物理名称。为此，在系统中，必须具有**将逻辑设备名转换为某物理设备名称的功能**。这会在系统中配置一张**逻辑设备表**。

#### 与设备无关的软件

**1.设备驱动程序的统一接口**
	一方面，要求每个**设备驱动程序与OS之间**都有着相同的接口。定义方面，要将**抽象的设备名映射到适当的驱动程序**上面。

**2.缓冲管理**
	I/O设备的运行速度远低于CPU的速度。为了缓和CPU和I/O设备之间的矛盾，提高CPU的利用率，现代OS中无一例外地分别为I/O设备配置了相应地缓冲区。

**3.差错控制**
①**暂时性错误：**发生暂时性事件引起的，如电源地波动，数据包丢失或延误性等。
②**持久性错误：**由持久性故障引起的，如电源掉电，磁盘损坏等。

**4.对独立设备的分配与回收**
系统中有两类设备：独占设备和共享设备。
**独站设备**：有系统来统一分配，不允许进程自行使用 ，有OS进行检查和分配。

**5.独立于设备的逻辑数据块**
不同类型地设别， 数据交换单位不同，读取和传输速率也各不相同。设备独立性软件能够**隐藏这些差异而被逻辑设备使用**，并向高层软件提供大小统一地逻辑数据块。

#### 设备分配

**1.设备分配中的数据结构**
**设备控制表DCT：**
	①设备类型：type ②设备标识符：deviceid ③设备状态：等待/不等待 忙/闲
	④**指向控制器表的指针**：该指针指向该**设备所连接的控制器的控制表。**
	⑤**重复执行次数或时间**：设别在工作中发生错误时应重复执行的次数。
	⑥**设备队列的队首指针**：凡因请求本设备而未得到满足的进程，应将其PCB按照一定的策略拍成一个请求队列，其队首指针指向队首PCB。(**请求本设备而未得到满足的进程**)
**控制器控制表、通道控制表和系统设备表：**
	①**控制器控制表(COCT)**：设置了 用于记录控制器情况的控制器控制表。
	②**通道控制表(CHCT)**：每个通道都有一张通道控制表。
	③**系统设备表(SDT)**：这是系统范围的数据结构，记录了系统中全部设备的情况，每个设备占一个表目，其中包括有**设备类型，设备标识符，设备控制表以及设备驱动程序的入口**。

**2.设备分配时应考虑的因素**
①**设备的固有属性：**
	独占设备的分配策略，共享设备的分配策略，虚拟设备的分配策略。
②**设备分配算法：**
	先来先服务，优先级高者优先。
③**设备分配中的安全性：**
	①**安全分配方式**：每当进程发出**I/O请求后**，便**进入阻塞状态**，直到其I/O操作完成时才被唤醒。
	②**不安全分配方式**：进程在发出I/O请求后仍继续运行，需要时又发出后续的I/O请求。**仅当所请求设备被占用时，才进入阻塞状态**。

**3.独占设备的分配程序**
**基本的设备分配程序**
	①**分配设备**：负责**查找系统设备表SDT**，若设备忙则放入设备队列上；否则根据情况将设备分配给进程。
	②**分配控制器**：查找**设备控制表DCT**，找到**控制器控制表COCT**，**请求**相应分**控制器**。
	③**分配通道**：在该COCT中由可找到与该控制器连接的通道的CHCT，再根据CHCT内的状态信息选择通道。
	只有设备，控制器，通道三者都分配成功时，这次的设备分配才算成功。

**设备分配程序的改进**
	为获得设备的独立性，进程应使用逻辑设备名请求I/O。这样，既可以查找一类设备的所有物理设备，**仅当所有该类设备都忙时，才把进程挂在该类设备的等待队列上**。只要有一个该类设备可用，系统便进一步计算分配该设备的安全性。

#### 逻辑设备名到物理设备名映射的实现

**1.逻辑设备表LUT**
每个表目中包含了**三项**：逻辑设备名，物理设备名 和 设备驱动程序的入口地址。

**2.逻辑设备表的设置问题**
**两种方式**设置逻辑设备表：
	第一种方式：是在**整个系统中只设置一张LUT**。不允许在LUT中具有相同的逻辑设备名，要求所有用户都不使用相同的逻辑设备名。
	第二种方式：为**每个用户设置一张LUT**。当用户登录时，为**用户建立一个进程**，同时也**建立一张LUT并放入进程的PCB中**。

## 用户层的I/O软件

#### 系统调用和库函数

**1.系统调用**
	一方面，为使诸进程能有条不紊地使用I/O设备，且能保护设备地安全性，**不允许运行在用户态地应用进程区直接调用运行在核心态的OS过程**。另一方面，**应用进程在运行时，又必须取得OS所提供的服务**，否则应用程序无法运行。因此出现了**系统调用**。

**2.库函数**
	在C语言中以及UNIX系统中，系统调用与各系统调用所使用的库函数几乎一一对应。微软也提高了一套过程为应用程序接口。C语言中提供了多种类型的库函数。

#### 假脱机(Spooling)系统

**假脱机技术：**将一台物理I/O设备虚拟为多台逻辑I/O设备，允许多用户共享一台物理I/O设备。
**1.假脱机技术**
	利用两个进程，一个模仿脱机输入，一个模仿脱机输出；此时的**外围操作和CPU对数据的处理同时进行**，我们把这种**在联机情况下实现的同时外围操作的技术称为SPOOLing技术**。

**2.SPOOLing的组成**
SPOOLing系统建立在通道技术和多道程序技术的基础上，以高速随即外村(通常为磁盘)为后援存储器。
SPOOLing系统主要有**四个部分组成**：
	① **输入井和输出井**：输入井模拟用于**收容I/O设备输入的数据**。输出井模拟用于**收容用户程序的输出程序**。
	② 输入缓冲区和输出缓冲区：输入缓冲区用于**存放输入设备传送的数据**，输出缓冲区用于**暂存输出井传送的数据**。
	③ 输入进程和输出进程：输入程序用于模拟将**用户数据从输入设备传送到输入缓冲区**。输出程序用于模拟把**用户要求输入的数据**从内存传送并存放到输出井。
	④ 井管理程序：用于**控制作业与磁盘井之间信息的交换**。

**3.SPOOLing系统的特点**
	①提高了I/O的速度。②将独占设备改造为共享设备。③实现了虚拟设备功能。

**4.假脱机打印机系统**
	①磁盘缓冲区
	②打印缓冲区
	③假脱机管理进程和假脱机打印进程。

假脱机管理进程完成两项工作：①在**磁盘缓冲区中为之申请一个空闲盘块**，将**打印的数据送入其中暂存**②为**用户进程申请一张空白的用户请求打印表**，**并将用户的打印要求填入其中**，再**将该表挂到假脱机文件队列上**。
假脱机打印进程：负责从假脱机文件队列上取出文件进行工作。

**5.守护进程**
	取消了假脱机管理进程，为打印机建立一个守护进程，由它执行一部分原来由假脱机管理进程实现的功能(第一项工作)。另一部分由请求进程自己完成(第二项工作)。

## 缓冲区管理

#### 缓冲的引入

**原因：** 4个
	①缓和CPU和I/O设备间**速度不匹配的矛盾**。
	②**减少**对CPU的**中断频率**，**放宽对CPU中断响应时间的限制**。
	③解决数据粒度不匹配，可以用于解决生产者和消费者之间交换的数据粒度。
	④提高CPU和I/O设备之间的并行性。

#### 单缓冲区和双缓冲区

**1.单缓冲区**
	单缓冲区是共享资源，生产者与消费者在使用缓冲区时必须互斥。

**2.双缓冲区**
	为了解决单缓冲区的问题，为生产者和消费者设置了**两个缓冲区**。也成为**缓冲对换**。
	在两台机器之间的通信，**单缓冲**任何时候只能实现**单方向数据传输**。**双缓冲**可以设置接收和发送缓冲区从而达到**双向数据传输**。	

#### 环形缓冲区

**1.环形缓冲区的组成**
	①多个缓冲区：用于装输入数据的**空缓冲区R**，**已装满**数据的缓冲区G，计算进程正在使用**现行工作缓冲区C**。
	②多个指针：计算进程下一个**可用缓冲区G**指针Nextg，输入进程下次**可用的缓冲区R**Nexti，指示计算进程**正在使用的缓冲区C**Current。

**2.唤醒缓冲区的使用**
	①Getbuf过程：获取可用的计算缓冲区。
	②Releasebuf过程：释放满的缓冲区。

**3.进程之间的同步问题**
可能出现的下述两种情况：
	①Nexti指针追赶上Nextg指针。意味着输入进程输入数据的速度大于计算进程处理数据的速度，**已把全部可用的空缓冲区装满，再无缓冲区可用。**
	②Nextg指针追赶上Nexti指针。这意味着输入数据的速度低于计算进程处理数据的速度，**使全部装有输入数据的缓冲区都被抽空，再无装有数据的缓冲区共计算进程提取数据。**

#### 缓冲池

缓冲首部一般包括缓冲区号，设备号，设备上的数据块号，同步信号量以及队列链接指针等。

**1.缓冲池的组成**
	①空白缓冲队列emq
	②输入队列inq
	③输出队列outq

**2.Getbuf过程和Putbuf过程**
	为每一个队列设置一个互斥信号量，又为每个缓冲队列设置一个资源信号量。实现同步与互斥。

**3.缓冲区的工作方式**
	①收容输入：调用Getbuf(emq)，Putbuf(inq, hin);从emq中取出缓冲区，并接收数据，接收完数据后把缓冲区放入inq中。
	②提取输入：调用Getbuf(inq)，Putbuf(inq, sin);从inq取出缓冲区，读取数据，然后把缓冲区放入emq中。
	③收容输出；调用Getbuf(emq)，Putbuf(outq, hout);从emq中取出缓冲区，并写入数据，然后把缓冲区放到outq中。
	④提取输出：调用Getbuf(outq)，Putbuf(emq, sout);从outq取出缓冲区，提取出数据，然后把缓冲区放入emq中。

## **磁盘存储器的性**能和调度

#### 磁盘性能简述

**1.数据的组织与格式**
	磁盘设备可包括一个或多个**物理盘片**，给个磁盘片分为一个或多个**存储面**(Surface)。每个盘面有若干个**磁道**(Track)，磁道之间留有必要的**间隙**(Gap)。**每条磁道上可存储相同数目的二进制位**。**每条磁道**又被从逻辑上划分成若干**扇区**。一个扇区称为一个盘块，各扇区之间保留一定的**间隙**。
	现代磁盘**不再把内外磁道划分为相同数目的扇区**，而是利用**外层磁道容量较内存磁道大的特点**，将**盘面划分成若干条环带**。
	同一环带内的所有磁道具有相同的扇区数。外层环带的扇区数比内层环带扇区数多。
	一个扇区：①**标识符字段**，磁道号、磁头号、扇区号三者标识②**数据字段**。

**2.磁盘的类型**
	①**固定头磁盘**：每条磁道上都一读/写磁头。I/O速度较快。用于大容量磁盘。
	②**移动头磁盘**：每一个面盘仅配有一个磁头。I/O速度较慢。用于中小心磁盘。

**3.磁盘访问时间**
	①**寻道时间Ts** **Ts = m * n + s**；启动磁臂时间s 磁头移动一条磁道时间m。
	②**旋转延迟时间Tr**：是指扇区移动到磁头下面所经历的时间。
	③**传输时间Tt**：**Tt = b / rN**；b为每次读写字节数，r为转速，N为一条磁道的字节数。
	**访问时间Ta**：**Ta = Ts + 1/2r + b/rN**；

#### 早期磁盘调度算法

**1.先来先服务(FCFS)**

**2.最短寻道时间优先(SSTF)**

#### 基于扫描的磁盘调度算法

**1.扫描算法**
	每次选择这样的进程来**调度**：既要访问的磁道在**当前位置内为距离最近者**，**磁头又逐步地从外向里移动**(然后在**从外向里**)，**直至再无更里面地磁道要访问**，避免了“饥饿”现象。

**2.循环扫描算法**
	调度方式：CSCAN算法规定**磁头单项移动**，只是自里向外移动，当磁头**移到最外地磁道并访问后**，**磁头立即返回到最里地欲访问磁道**，即**最小紧接着最大构成循环**。

**3.NStepSCAN 和 FSCAN调度算法**

**1.NStepSCAN算法**
	SSTF、SCAN 和 CSCAN都会出现磁臂停留在某处不懂的情况，称为**磁臂沾着**(对某一磁道较高的访问频率)。
	N步SCAN算法时将磁盘**请求队列分成若干长度为N各子队列**，磁盘调度**先按FCFS算法一次处理这些子队列**。而**每处理一个队列时又是按SCAN算法**，对一个队列处理完后，在处理其他队列。这样可以**避免粘着现象**。性能接近**SCAN算法**，N = 1时为**FCFS算法**。

**2.FSCAN算法**
	FSCAN算法实质上时N步SCAN算法地简化，即FSCAN只将磁盘**请求队列分成两个子队列**。一个是**当前所有请求磁盘I/O的进程**形成的队列，另一个是**新出现**的**所有请求磁盘I/O的进程**放出**等待处理**的请求队列中。

