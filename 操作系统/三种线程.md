#### 内核线程

内核线程就是内核的分身，一个分身可以处理一件特定事情。这在处理异步事件如异步IO时特别有用。内核线程的使用是廉价的，唯一使用的资源就是内核栈和上下文切换时保存寄存器的空间。支持多线程的内核叫做多线程内核(Multi-Threads kernel )。

内核线程只运行在内核态，不受用户态上下文切换拖累
	**处理器竞争**：可以在全系统范围内竞争处理器资源
	**使用资源**：唯一使用的资源是内核栈和上下文切换时保持寄存器的空间
	**调度**：调度的开销可能和进程自身差不多昂贵
	**同步效率**：资源的同步和数据共享比整个进程的数据同步和共享要低一些。

#### 轻量级(进)程(内核控制线程)

LWP与普通进程的区别也在于**它只有一个最小的执行上下文和调度程序所需的统计信息**，而这也是它之所以被称为轻量级的原因。

轻量级线程(**LWP**)又称轻型进程，是一种由**内核支持的用户线程**。它是基于内核线程的高级抽象，因此只有先支持内核线程，才能有LWP。**每一个进程有一个或多个LWP**，每个LWP由一个内核线程支持。这种模型实际上就是**==一对一线程模型==**。
	**处理器竞争**：因**与特定内核线程关联**，因此可以在全系统范围内竞争处理器资源
	**使用资源**：与**父进程共享进程地址空间**
	**调度**：像普通进程一样调度

**LWP可把用户线程与内核线程连接起来**，用户线程可以通过LWP来访问内核，但内核所看到的总是多个LWP而看不到用户级线程。**LWP实现了内核与用户级线程之间的隔离**。

由于**每个LWP都与一个特定的内核线程关联**，因此每个LWP都是一个独立的线程调度单元。即使**有一个LWP在系统调用中阻塞，也不会影响整个进程的执行**。

轻量级进程具**有局限性**：
	首先，大多数LWP的操作，如建立、析构以及同步，都需要进行系统调用。**系统调用的代价相对较高**：需要在user mode和kernel mode中切换。
	其次，每个LWP都需要有一个内核线程支持，因此LWP要消耗内核资源（内核线程的栈空间）。因此**一个系统不能支持大量的LWP**。

#### 用户线程

用户线程是**完全建立在用户空间的线程库**，用户线程的创建、调度、同步和销毁全又库函数在用户空间完成，不需要内核的帮助。因此这种线程是极其低消耗和高效的。
	**处理器竞争**：单纯的用户线程是建立在用户空间，其对内核是透明的，因此其所属进程单独参与处理器的竞争，而进程的所有线程参与竞争该进程的资源。
	**使用资源**：与所属进程共享进程地址空间和系统资源
	**资源**：由在用户空间实现的线程库，在所属进程内进行调度

LWP虽然本质上属于用户线程，**但LWP线程库是建立在内核之上的，LWP的许多操作都要进行系统调用**，因此效率不高。而这里的**用户线程指的是完全建立在用户空间的线程库**，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的。

这种模型对应着**==多对一线程模型==**，其缺点是一个用户线程如果阻塞在系统调用中，则整个进程都将会阻塞。

#### 加强版的用户线程——用户线程+LWP

这种模型对应着**==多对多模型==**。

用户线程库还是完全建立在用户空间中，因此用户线程的操作还是很廉价，因此可以建立任意多需要的用户线程。

操作系统提供了LWP作为用户线程和内核线程之间的桥梁。LWP还是和前面提到的一样，具有内核线程支持，是内核的调度单元，并且用户线程的系统调用要通过LWP，因此进程中某个用户线程的阻塞不会影响整个进程的执行。

用户线程库将建立的用户线程关联到LWP上，LWP与用户线程的数量不一定一致。当内核调度到某个LWP上时，此时与该LWP关联的用户线程就被执行。

#### Linux使用的线程库

LinuxThreads是用户空间的线程库，所采用的是**线程-进程1对1模型(即一个用户线程对应一个轻量级进程，而一个轻量级进程对应一个特定的内核线程)**，将线程的调度等同于进程的调度，调度交由内核完成，而线程的创建、同步、销毁由核外线程库完成（LinuxThtreads已绑定到 GLIBC中发行）。

在LinuxThreads中，由专门的一个管理线程处理所有的线程管理工作。当进程第一次调用pthread_create()创建线程时就会先 创建(clone())并启动管理线程。后续进程pthread_create()创建线程时，都是管理线程作为pthread_create()的调用者的子线程，通过调用clone()来创建用户线程，并记录轻量级进程号和线程id的映射关系，因此，用户线程其实是管理线程的子线程。

LinuxThreads只支持调度范围为PTHREAD_SCOPE_SYSTEM的调度，默认的调度策略是SCHED_OTHER。
用户线程调度策略也可修改成SCHED_FIFO或SCHED_RR方式，这两种方式支持优先级为0-99,而SCHED_OTHER只支持0。

- **SCHED_OTHER** 分时调度策略，
- **SCHED_FIFO** 实时调度策略，先到先服务
- **SCHED_RR** 实时调度策略，时间片轮转

SCHED_OTHER是普通进程的，后两个是实时进程的（一般的进程都是普通进程，系统中出现实时进程的机会很少）。SCHED_FIFO、 SCHED_RR优先级高于所有SCHED_OTHER的进程，所以只要他们能够运行，在他们运行完之前，所有SCHED_OTHER的进程的都没有得到 执行的机会

## LWP

LWP，即轻量级进程（Lightweight Process），在计算机操作系统中扮演着重要角色，尤其是在实现多任务和多线程处理方面。以下是为什么要有LWP的几个主要原因：

### 1. 资源共享与高效利用

- **共享资源**：LWP允许进程之间共享大部分逻辑地址空间和系统资源，这种共享机制可以显著提高资源利用率，减少不必要的资源复制和开销。
- **轻量级**：与传统进程相比，LWP的创建和切换开销较小，因为它们通常只在用户态下管理，不需要频繁地在用户态和内核态之间切换。这种轻量级特性使得LWP成为处理大量并发任务时的理想选择。

### 2. 提供灵活的线程实现

- **内核不支持线程时的替代方案**：在内核不支持线程的情况下，LWP可以很方便地提供线程的实现。它们通过模拟线程的行为，允许应用程序在单个进程内并行执行多个任务。
- **灵活性与可移植性**：LWP可以在不同的操作系统和平台上实现，提供了一种跨平台的线程实现方式。这对于需要在多种环境下运行的应用程序来说非常重要。

### 3. 支持多任务并发处理

- **多任务执行**：LWP允许单个进程内部并发执行多个任务，从而提高了应用程序的响应性和吞吐量。这对于需要处理大量并发请求的应用程序（如Web服务器、数据库服务器等）来说至关重要。
- **独立执行单元**：每个LWP都作为一个独立的执行单元存在，拥有自己的上下文环境（如程序计数器、堆栈等），可以在不影响其他LWP的情况下独立执行。

### 4. 与其他进程的关系

- **父子关系**：LWP可以与其他进程建立父子关系，这种关系使得系统可以更好地管理进程和线程之间的依赖关系。
- **系统调用与信号传递**：LWP可以通过系统调用来与其他进程或线程进行通信和协作，也可以通过信号传递机制来实现同步和互斥等同步原语。

### 5. 适应特定应用场景

- **嵌入式系统**：在资源受限的嵌入式系统中，LWP提供了一种轻量级的并发处理方式，可以在满足系统性能要求的同时减少资源消耗。
- **云计算与大数据**：在云计算和大数据等现代计算环境中，LWP可以帮助实现高效的资源调度和任务并行处理，提高整个系统的吞吐量和可靠性。

综上所述，LWP的存在是为了提供一种更高效、更灵活且更适用于特定应用场景的并发处理方式。它们通过共享资源、提供灵活的线程实现、支持多任务并发处理以及与其他进程建立良好关系等方式，为现代计算环境提供了强大的支持。
