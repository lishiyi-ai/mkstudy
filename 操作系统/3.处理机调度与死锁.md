## 处理机调度的层次和调度算法的目标

<<<<<<< HEAD
#### 处理机调度的层次

**1.高级调度**
	又称长程调度或作业调度。调度对象是作业。
**2.低级调度**
	又称进程调度或短程调度，其所调度对象是进程(或内核级线程)。
**3.中级调度**
	又称内存调度，引入终极调度主要目的是：提高内存利用率和系统吞吐量。

#### 处理机调度算法的目标

**1.处理机调度算法的共同目标**
	**①资源利用率**
		CPU的利用率 = CPU有效工作时间/(CPU有效工作时间 + CPU空闲等待时间)
	**②公平性**：诸进程都获得合理的CPU时间，不会发生饥饿现象。
	**③平衡性**：尽可能保持系统资源使用的平衡性。
	**④策略强制执行**：对所制定订的策略其中包括安全策略，只要需要，就必须予以准确地执行。
**2.批处理系统的目标**
	①平均周转时间短。②系统吞吐量高。③处理及利用率高。
**3.分时系统的目标**
	①响应时间快。②均衡性
**4.实时系统的目标**
	①截止时间的保证。②可预测性。

## 作业和作业调度

#### 批处理系统中的作业

**1.作业和作业步**
	**作业：**比程序更广泛的概念，不仅包含了通常的程序和数据，而且还应配有一份作业说明书。
	**作业步：**每个作业都必须经过若干个相对独立，又相关联的顺序**加工步骤**才能得到结果。**一个加工步骤就是一个作业步**。
**2.作业控制块(JCB)**
**3.作业运行的三个阶段和三种状态**
	①收容阶段：将作业提交到硬盘，建立JCB，放入作业**后备队列**中。状态为**后备状态**。
	②运行阶段：作业被作业调度选中后，便为它分配必要的资源和建立进程，并加入**就绪队列**，变为**运行状态**。
	③完成阶段：作业运行完成、或发生异常情况而提前结束时，作业进入了**完成状态**。此时会**回收分配的资源**。

#### 作业调度的主要任务

​	1.接纳多少作业。2.接纳哪些作业(调度算法)。
#### ==先来先服务(FCFS)和短作业优先(SJF)调度算法==

**FCFS：**按照作业到达的先后次序来进行调度。
**SJF：**按照作业长短来计算优先级，作业越短，优先级越高。

#### ==优先级调度算法和高响应比优先算法==

**优先级调度算法PSA：**按照作业的优先级，基于作业的紧迫程度，然后按照优先级高低次序调度。
**高响应比优先调度算法HRRN：**
	**优先权 = (等待时间 + 要求服务时间) / 要求服务时间。**
	等待时间相同，要求服务时间越短越优先；服务时间相同时，越短等待时间越优先；

## 进程调度

#### 进程调度的任务、机制和方式

**1.进程调度的任务**
	①保存处理机的现场信息。②按某种算法选取进程。③把处理器分配给进程。
**2.进程调度机制**
	①排队器。②分派器。③上下文切换器。
**==3.进程调度方式==**
	①抢占式。②非抢占式。

#### 轮转调度算法

基于**时间片**的轮转调度算法，根据作业大小**选取不同的时间片**，根据时间片进行切换。若时间片未用完就**完成**，则提前调度，若**用完**了则开始将其**放到就绪队列队尾**，并重新调度新任务。

#### 优先级调度算法

**分类：**
	①非抢占式优先级调度算法：把处理机分配给就是队列中优先级最高的进程后，**一直执行下去直到完成，或放弃处理**，才可重新分配给另一优先级最高的进程。
	②抢占式优先级调度算法：处理器**总是选择优先级更高的的进程进行运行**。更高优先级的作业出现时，会中断当前作业的运行，转而去运行更高优先级的作业。
**优先级类型：**
	①**静态优先级**：依据**进程类型**，进程**对资源的需求**，**用户要求**，确定其优先级。
	②**动态优先级**：有一个初始优先级，随后**随着进程的推进或等待时间的增加而改变**。

#### 多队列调度算法

将就绪队列**一个拆分为若干个**，将**不同类型或性质的进程固定分配在不同的就绪队列中**，**不同队列采用不同的调度算法**，**设置不同优先级**。

#### 多级反馈队列调度算法

**1.调度机制**
	①设置多个就绪队列。②每个队列都采用FCFS算法。③按队列优先级调度
**2.调度算法的性能**
	①终端型用户。在**第一**队列②短批处理作业用户。在**第一**队列，或**第二，第三**队列中③长批处理作业用户。按照从**1到n**的队列执行。

#### 基于公平原则的调度算法

**1.保证调度算法**
	①计算每个进程的处理机时间的比率，即**实际执行的处理时间** 和 **应获得的处理机时间之比**。
	②选择比率最小的进程，将处理机分配给它。
**2.公平分享调度算法**
	分配给每个进程相同的处理及时间，对于进程公平对于用户不公平。该算法公平性主要针对用户而言，使**所有用户能获得相同(或者合理的时间比例)的处理机时间**。

## 实时调度

#### 实时调度的基本条件

**1.必要的信息**
	就绪时间，开始截止时间 和 完成截止时间，处理时间，资源要求，优先级。
**2.系统处理能力强**
**3.采用抢占式调度机制**
**4.具有快速切换机制**
	①对中断的快速响应能力②快速的任务分配能力。

#### 实时调度算法分类

**1.非抢占式调度算法**
	①非抢占式**轮转**调度算法 用于**要求不太严格**的实时控制系统。
	②非抢占式**优先**调度算法 用于**有一定要求**的实时控制系统。
**2.抢占式调度算法**
	①**基于时钟中断**的抢占式优先级调度算法 用于大多的实时系统。
	②**立即抢占**的优先级调度算法 **用于严格要求的实时任务**。

#### 最早截止时间优先EDF算法

1.非抢占式调度方式用于**非周期实时**任务
2.抢占式调度用于**周期实时**任务

#### 最低松弛度优先LLF算法

该算法在确定任务的优先级时，根据的时任务的紧急(或松弛)程度。**松弛度 = 必须完成时间  - 本身运行时间 - 当前时间**。
算法不断根据松弛度调整运行在CPU上的进程。

#### 优先级倒置

**1.优先级倒置的形成**
	由于资源互斥，导致的**高优先级进程所需资源被低优先级进程占有**，而cpu被高优先级进程占有导致的现象。
**2.优先级倒置的解决方法**
	①临界区不可抢占，保证当前进程能够正确释放掉互斥资源后在退出该进程。
	②优先级继承，让高优先级进程在互斥资源被其他低优先级进程时，暂时改变自身的优先级进程，实现cpu的让步。

=======
## 作业和作业调度

## 进程调度

## 实时调度

>>>>>>> 6f37266fd4d2ab2f34d4870862266a22f8f74bf8
## 死锁概述

#### 资源问题

<<<<<<< HEAD
**1.可重用性资源和消耗性资源**
**可重用性资源的性质：**
	①只能分配给一个进程使用。②资源使用的顺序：请求资源，使用资源，释放资源。③数目固定。
**消耗性资源的性质：**
	①数目不断变化。②可不断地创建。③可被进程消耗，不在返回给该资源类。
**2.可抢占性资源和不可抢占性资源**
**可抢占资源：**某进程在获得这类资源后，该资源可以被其它进程或系统抢占。
**不可抢占资源：**资源一旦被分配给某进程后，只有得到进程用完释放后，才能回收重新分配。

#### 计算机系统中的死锁

1.竞争**不可抢占性资源**引起死锁。
​2.竞争**可消耗资源**引起死锁。
​3.进程**推进顺序不当**引起的死锁。

#### 死锁的定义、必要条件和处理方法

1.**死锁的定义**：如果一组进程中的**每一个进程都在等待仅由该组进程中的其他进程才能引发的事件**。
​2.产生死锁的**必要条件**：
​	(1)**互斥条件**(2)**占有且等待条件(请求与保持条件)**(3)**不可抢占条件**(4)**循环等待条件**
​3.处理死锁的**方法**
​	(1)**预防死锁**(2)**避免死锁**(动态)(3)**检测死锁**(4)**解除死锁**
=======
#### 计算机系统中的死锁

​	1.竞争不可抢占性资源引起死锁。
​	2.竞争可消耗资源引起死锁。
​	3.进程推进顺序不当引起的死锁。

#### 死锁的定义、必要条件和处理方法

​	1.死锁的定义：如果一组进程中的**每一个进程都在等待仅由该组进程中的其他进程才能引发的事件**。
​	2.产生死锁的必要条件：
​		(1)**互斥条件**(2)**占有且等待条件(请求与保持条件)**(3)**不可抢占条件**(4)**循环等待条件**
​	3.处理死锁的方法
​		(1)**预防死锁**(2)**避免死锁**(动态)(3)**检测死锁**(4)**解除死锁**
>>>>>>> 6f37266fd4d2ab2f34d4870862266a22f8f74bf8

## 预防死锁

#### 破坏"请求与保持"条件

<<<<<<< HEAD
1.**一次性申请所需的全部资源**。
​2.运行进程**只获得运行初期所需的资源后**，便开始运行。运行过程中**逐步释放资源**和**请求新资源**。

#### 破坏"不可抢占"条件

当已经**保持了某些不可被抢占资源的进程**，提出新的资源**请求而不能得到满足时**，必须**释放已经保持的所有资源**，以后重新申请。

#### 破坏"循环等待"条件

对所有**资源类型进行线性排序**，请求资源必须按照线性排序的序号递增的形式进行请求。
=======
​	1.一次性申请所需的全部资源
​	2.运行进程只获得运行初期所需的资源后，便开始运行。运行过程中**逐步释放资源**和**请求新资源**。

#### 破坏"不可抢占"条件

​	当已经**保持了某些不可被抢占资源的进程**，提出新的资源**请求而不能得到满足时**，必须**释放已经保持的所有资源**，以后重新申请。

#### 破坏"循环等待"条件

​	对所有**资源类型进行线性排序**，请求资源必须按照线性排序的序号递增的形式进行请求。
>>>>>>> 6f37266fd4d2ab2f34d4870862266a22f8f74bf8

## 避免死锁

#### 系统安全状态

<<<<<<< HEAD
**1.安全状态**
	允许进程**动态地申请资源**，但系统在进行资源分配之前，应先**计算此次资源分配的安全性**。
**2.安全状态之例**
**3.由安全状态向不安全状态的转换**
	如果**不按照安全序列分配资源**，则系统可能会由**安全状态进入不安全状态**。

#### ==利用银行家算法避免死锁==

**1.银行家算法的数据结构**
	①可利用资源向量Available
	②最大需求矩阵Max
	③分配矩阵Allocation
	④需求矩阵Need
	Need[i, j] = Max[i, j] - Allocation[i, j]
**2.银行家算法**
	①请求小于需求，则转向②。②需求小于可用，则转向③。③**试着分配资源**，并修改数据结构的数值。
	④**执行安全性算法**，试探此次资源分配后是否处于安全状态，安全则分配，否则让进程等待。 
**3.安全性算法**
	①设置两个向量，**工作向量Work**，**Finish向量**。②在集合进程中找到一个**满足以下条件的进程**：Finish = false；Need <= Work
	③进程获得资源后，可**顺利执行**，**并释放所有分配的资源**。 **标志其为Finish = true**。④**所有进程的Finish = true，表示系统处于安全状态**。
**4.银行家算法之例**
=======
#### ==银行家算法避免死算==
>>>>>>> 6f37266fd4d2ab2f34d4870862266a22f8f74bf8

## 死锁的检测与解除

#### 死锁的检测

<<<<<<< HEAD
1.**资源分配图**
	S为死锁状态的充分条件：当且仅当S状态的资源分配图不可完全简化。
2.**死锁定理**：在资源分配图中，找出一个既不阻塞又非独立的进程结点，逐步释放，知道没有所有的结点被消除完。否则则有死锁。
3.**死锁检测中的数据结构**
	①可利用资源向量**Available**
	②**不占用资源的进程记录L表中**
	③从进程集合中找到**Request <= Work**的进程：①**简化资源分配图，增加工作向量**。②将他**记入L表**中。
	④ 若**不能把所有进程计入L表**，则表中**S的资源分配图不可完成简化**，因此会发生死锁。

#### 死锁的解除

1.**抢占资源**
2.**终止(或撤销)进程**
**终止进程的方法：**
	1.终止所有死锁进程。
	2.逐个终止进程，直至有足够资源，以打破循环等待。
**付出代价最小的死锁解除算法：**
	一种是：计算每一种可能选出最小代价的一种，不实际。
	另一种比较有效的是：逐层选择，选择每一层代价最小的后在开始这一状态下的下一层，直到不在死锁那一层停止。
=======
​	1.**资源分配图**
​	2.**死锁定理**：在资源分配图中，找出一个既不阻塞又非独立的进程结点，逐步释放，知道没有所有的结点被消除完。否则则有死锁。
​	3.死锁检测中的数据结构

#### 死锁的解除

​	1.**抢占资源**
​	2.**终止(或撤销)进程**

>>>>>>> 6f37266fd4d2ab2f34d4870862266a22f8f74bf8
