## 存储器的层次结构

#### 多层结构的存储器系统

**1.存储器的多层次结构**
	存储器至少应具有**三级**：CPU寄存器，主存，辅存。
	根据**具体功能**具体细分为：寄存器，高速缓存，主存存储，磁盘缓存，固定磁盘，可移动存储介质等6层。

**2.可执行存储器**
	寄存器和主存储器又称为可执行存储器。计算机对其采用的访问机制与辅存的访问机制不同。
	不同层次的存储介质，由操作系统进行统一管理。操作系统的**存储管理**负责对可执行**存储器的分配**，回收以及提供在**存储层次间数据移动的管理机制**。

#### 主存储器和寄存器

**1.主存储器**
	主存储器简称内存或主存，用于**保存进程运行时的程序和数据**，也称可执行存储器。
	由于主存储器访问速度远低于CPU执行指令的速度，为缓和这一矛盾，在计算机系统中引入了寄存器和高速缓存。

**2.寄存器**
	寄存器具有与处理机相同的速度，故对**寄存器的访问速度最快**，完全能与CPU协调工作。

#### 高速缓存和磁盘缓存

**1.高速缓存**
	它介于**寄存器和存储器之间**的存储器，主要用于**备份主存中较常用的数据**，以**减少处理机对主存储器的访问次数**，这样可大幅度地提高程序执行速度。

**2.磁盘缓存**
	由于目前**磁盘I/O速度远低于对主存的访问速度**，为了**缓和两者之间在速度**上的不匹配，而设置了磁盘缓存，主要用于**暂时存放频繁使用的一部分磁盘数据和信息**。(不是实际存在的存储器，而是利用主存的部分存储空间暂时存放磁盘中读出的信息)。

## 程序的装入和链接

程序运行的几个步骤：编译，链接，装入
#### 程序的装入

由装入程序(Loader)将装入模块装入内存

**1.绝对装入方式**
	当计算机系统很小时，仅能运行单道程序时，完全有可能知道程序将驻留在内存的什么位置，因此采用绝对装入方式，**直接使用物理地址**。

**2.可重定位装入方式**
	根据起始地址，计算**相对地址**，得到正确的物理地址在使用，可以根据内存的而具体情况将装入模块装入到内存的适当位置。

**3.动态运行时的装入方式**
	动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换为物理地址，而是把**这种地址转换推迟到程序真正要执行时才进行**。

#### 程序的链接

由链接程序将编译后形成的**一组目标模块以及它们所需要的库函数链接在一起**，形容一个完整的装入模块。

**1.静态链接**
	在程序运行前，先将各个目标模块及它们所需的库函数链接成一个完整的装配模块，以后不在拆开。
要解决的问题：
	① 相对地址进行修改②变换外部调用符号

**2.装入时动态链接**
	这是指用户源程序编译后所得到的一组模块，再装入内存时，采用边装入边链接的链接方式。
优点：
	①便于修改和更新②便于实现对目标模块的共享。

**3.运行时动态链接**
	对**某些模块的链接推迟到程序执行时才进行**，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块，并将之装入内存，将其链接到调用者模块上。这样可以**加快程序的装入过程**，而且可以**节省大量的内存空间**。

## ==连续分配存储管理方式==

#### 单一连续的分配

在单道程序环境下，当时的存储器管理方式是把内存分为**系统区**和用户区两个部分，系统区由OS使用，用户内存区仅有一套用户程序，即整个内存的**用户空间由该程序独占**。

#### 固定分区分配

将整个用户空间划分为若干个固定大小的区域，在每一个分区中只装入一道作业。

**1.划分分区的方法**
	①分区大小相等②分区大小不等

**2.内存分配**
	分区按其大小进行排队，并为之建立一张分区使用表，当程序需要装入时，按大小检索该表，并选择未分配的分区分配给该程序。
	缺点：会造成存储空间浪费。

#### 动态分区分配

根据进程的实际需要，动态地为之分配内存空间。

**1.动态分区分配的数据结构**
	①空闲分区表②空闲分区链

**2.动态分区分配算法**
	后面介绍

**3.分区分配操作**
**分配内存：**利用某种分配算法，从空闲分区链中找到所需大小分区，若剩余空间不可再切割，则全部分配， 否则在切割。
**回收内存：**
	①回收区与插入点的前一个空闲分区F1相邻接
	②回收区与插入点的后一个空闲分区F2相邻接
	③回收区同时与插入点的前、后两个分区邻接
	④回收区既不与F1邻接，也不与F2邻接

#### 基于顺序搜索的动态分区分配算法

**1.首次适应算法**
	FF算法要求空闲分区链以地址递增的次序链接。在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区位置。
	缺点：低地址部分不断被划分，会产生许多难以利用的、很小的空闲分区，称为碎片。每次都从低地址开始，会增加查找开销。

**2.循环首次适应算法**
	为避免低地址部分留下许多很小的空闲分区，以及减少查找可用空闲分区的开销，循环首次适应算法在位进程分配内存空间，**每次从上一次找到的空闲分区的下一个空闲分区开始查找**，直至找到i一个能满足要求的空闲分区。
	缺点：缺乏大的空闲分区

**3.最佳适应算法**
	每次为作业分配内存时，总是把**能满足要求，又是最小的空闲分区分配给作业**，避免“大材小用”。要求空闲分区按照从小到大的顺序形成空闲分区链。
	缺点：在存储器中会留下许多难以利用的碎片。

**4.最坏适应算法**
	**总是选择最大的空闲区**，从中分割一部分存储空间给作业使用，以至于存储器中缺乏大的空闲分区。算法要求空闲分区按照从大到小的顺序形成空闲分区链。

#### 基于索引搜索的动态分区分配算法

**1.快速适应算法**
	又称为**分类搜索算法**，是**将空闲分区根据其容量大小进行分类**，对每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样系统中存在多个空闲区链表。
	优点：查找效率高
	缺点：为了有效合并分区，在分区归还主存时的算法复杂，系统开销较大。一个分区属于一个进程，存在一定空间浪费。

**2.伙伴系统**
	该算法规定，无论已分配分区或空闲分区，其他小均为2的k次幂。对于一个长度为n的存储空间，首先计算一个i值，使得2的i-1次幂 < n < 2的i次幂。**然后按照i逐步增加的方式寻找可用分区**，直到找到一个可用的空闲分区。

**3.哈希算法**
	哈希算法就是利用哈希快速查找的优点，以及空闲分区在可利用空闲区表中的分布规律，建立哈希函数，**构造一张以空闲分区大小为关键字的哈希表**，**该表的每一个表项记录了一个对应的空闲分区链表的头指针**。

#### 动态可重定位分区分配

**1.紧凑**
	通过移动内存中作业的位置，把原来多个分散的小分区拼接成一个大分区的方法，称为 紧凑。
	存在问题：**每紧凑一次，就要对移动了的程序或数据的地址进行修改**，这是相当麻烦的事情，而且还大大地影响到系统的效率。

**2.动态重定位**(不断修改程序起始地址即可)
	为使地址的转换不会影响到指令的执行速度，必须有硬件地址变化机构的支持，**即须在系统中增设一个重定位寄存器**，**用来存放程序在内存中的起始地址**。程序在执行时，**真正访问的内存地址时相对地址与重定位寄存器中的地址相加而形成**。

**3.动态重定位分区分配算法**
	**动态重定位分区分配算法与动态分区算法基本上相同**，差别仅在于：在这种分配算法中，**增加了紧凑功能**。

## 对换(Swapping)

#### 多道程序环境下的对换技术

**1.对换的引入**
**原因：**
	一方面，**内存中的某些进程由于某些事件尚未发生而被阻塞运行**，但它却占用了大量的内存。
	另一方面，**有许多作业，因内存空间不足，一直驻留在外存**，而不能进入内存。

**2.对换的类型**
	①整体兑换，又称进程兑换。
	②页面(分段)对换，**以进程的一个“页面” 和 “分段”为单位进行的**，则分别称之为“页面对换” 或 “分段兑换”，又统称 “部分对换”。
	系统必须能实现三个方面的功能：对对换空间的管理，对进出的换出和进程的换入。

#### 对换空间的管理

**1.对换空间管理的主要目标**
具有对换功能的OS中，通常把**==磁盘空间分为文件区和对换区==**。
	①对文件管理的主要目标：**提高文件存储空间的利用率**，然后才是**提高对文件的访问速度**，采用**离散分配方式**。
	②对对换空间管理的主要目标：**提高进程换入和换出的速度**，然后才是**提高文件存储空间利用率**。采用**连续分配方式**。

**2.对换区空闲盘块管理中的数据结构**
	使用空闲分区表或空闲分区链。在空闲分区表的每个表目中，应包含两项：**对换区的首址及其大小**，分别用**盘块号 和 盘块数**表示。

**3.对换空间的分配与回收**
	与动态分区分配相同。

#### 进程的换出与换入

**1.进程的换出**
**选择被换出的进程**：检查内存中处于阻塞状态或睡眠状态的进程，按优先级低的先换出的顺序进行换出，有时还需要考虑内存的驻留时间。
**进程换出过程**：在对进程换出时，**只能换出非共享的程序和数据段**，而且那些**共享的程序和数据段**，只要还有进程需要它，就**不能被换出**。换出**首先申请对换空间**，然后开始对换。对换后，**对该进程的进程控制块和内存分配表中等数据结构做相应的修改**。

**2.进程的换入**
查看PCB集合中所有进程的状态，从中找出“就绪”状态但已换出的进程。按照出去越久的，越先换入。兑换成功后，继续进行交换，直到外存再无“就绪且换出”，或已无足够内存交换，才停止

## ==分页存储管理方式==

如果允许将**一个进程直接分散地装入到许多不相邻接的分区中**，便可充分地利用内存空间，基于这一思想产生了**离散分配方式**。根据在离散分配时所分配地址空间地基本单位的不同，又可将**离散分配分为以下三种**：
	**①分页存储管理方式②分段存储管理方式③段页式存储管理方式**

#### 分页存储管理的基本方法

**1.页号和物理块**
	①页面：分页存储管理将进程的**逻辑地址空间分成若干个页**，并为各页加以编号，从0开始。相应地，也把**内存的物理地址空间分成若干块**，同样加以编号。由于**进程的最后一页经常装不满一块**， 而形成了不可利用的碎片，称之为**“页内碎片”**。
	②页面大小：在分页系统中，若选择过小的页面大小，虽然一方面可以**减小内存碎片**，起到**减少内存碎片的总空间的作用**，利于**提高内存利用率**；另一方面却会造成进程**每个进程占用较多的页面**，从而导致**页表过长**，占用大量内存，**降低换进换出的效率**。反之则优缺点相反。

**2.地址结构**
	页号P(31 - 12)位移量W(11 - 0)；给定逻辑地址A，页面大小L，则 **P = INT[A/L]，d = [A] MOD L**;

**3.页表**
	在分页系统中，**允许将进程的各个页离散地存储在内存的任一物理块**中。**系统为每个进程建立了一张页面映像表**，简称页表。
	页表实现**页号**到**物理块号**的**地址映射**。

#### 地址变换机构

将用户地址空间中的逻辑地址转换为内存空间中的物理地址。

**1.基本的地址变换机构**
	页表功能是由一组专门的寄存器来实现的。一个页表项用一个寄存器，但着这种情况太昂贵。
	页表大多驻留在内存中，系统中只设置一个**页表寄存器PTR**，其中存放**页表在内存的始址和页表长度**。
	平时进程未执行时，**页表的始址和页表长度**存放在本进程的**PCB**中，只有在调度到某进程时，才将两个数据转入页表寄存器中。
	查询过程中若页号超过页表长度，也会产生**越界中断**，也好查找出的**物理块号和页内地址组成物理地址**。

**2.具有快表的地址变换机构**
	由于**页表是存放在内存中的**，这使CPU在每存取一个数据时，都要两次访问内存，使得**计算机处理速度降低近1/2**。
	为了提高地址变换速度，增设一个具有**并行查寻能力的特殊高速缓冲寄存器**，又称“联想寄存器”，即**“快表”**(TLB)。
	在CPU给出有效地址后，**先查快表**，如果快表**有则取出使用**；若无，否则**查页表**，将**结果存入快表，并取出使用**。

#### **访问内存的有效时间**

有效访问时间：分为第一次访问内存时间与第二次访问内存时间之和（无快表）。
	**EAT = t + t = 2t**
引入快表以后：
	**EAT = a * λ +  (t + λ)(1-a) + t = 2t + λ - t*a**
**a为命中率，λ为查找快表所需要时间，t为一次内存访问时间。**

#### 两级和多级页表

**1.两级页表**
对于难于找到大的连续的内存空间来存放页表的问题，可利用将**页表进行分页的方法**，使**每个页面的大小与内存物理块的大小相同**，并为他们进行**编号**，然后**离散地将各个页面分别存放在不同的物理块**中，同样，也要为**离散分配地页表在建立一张页表**，称为**外层页表**，在**每个页表项中记录了页表页面的物理块号**。

两级页表结构：外页号，外层页内地址，页内地址。

**2.多级页表**
	设置更多级页表，对地址进行管理。

#### 反置页表

**1.反置页表的引入**
	反置页表为**每一个物理块设置一个页表项**，并将它们按**物理块的编号排序**，其中的**内容则是页号和所隶属进程的标识符**。

**2.地址变换**
	在利用反置页表进行地址变换时，是**根据进程标识符和页号，去检索反置页表**(可以采用哈希算法来进行检索)。如果检索到与之匹配的页表项，则该页表项中的**序号i便是该页所在的物理块号**，可以用**该块号和页内地址一起构成物理地址送内存地址寄存器**。
	使用反置页表，在多级页表情况时，只有在所需页面不在内存时，才使用它。

## ==分段存储管理方式==

#### 分段存储管理的引入

**原因：**一方面是由于通常的**程序可以分为若干个段**。另一方面，实现和满足**信息共享，信息保护，动态链接，以及信息的动态增长**等需要，也都是以段为基本单位。

**1.方便编程**
	逻辑地址是由段名 + 段内偏移决定，方便编程，可读性高

**2.信息共享**
	在实现对程序和数据的共享时，是以信息的逻辑单位为基础，**段可以是信息的逻辑单位。**

**3.信息保护**
	信息保护同样是**以信息的逻辑单位为基础的**，而且经常时以一个过程、函数或文件为基本单位进行保护。

**4.动态增长**
	在实际应用中，往往存在着一些段，尤其是数据段，在她们使用的过程中，由于数据量的不断增加，而使数据段动态增长，**相应地他所需要的存储空间也会增长**。段能很好应对这一情况。

**5.动态链接**
	动态链接要求是以目标程序作为链接地基本单位，因此分段存储管理非常适合于动态链接。

#### 分段系统的基本原理

**1.分段**
	分段地址中地地址具有如下结构：**段号(31 - 16)，段内地址(15 - 0)；**

**2.段表**
	分段式存储管理系统中，则是为**每个分段分配一个连续的分区**。进程中的各个段，可以离散地转入内存中不同地分区中。
	系统中，需为每个进程建立一张段映射表，简称**段表**。段表中存放了段在**内存中的起始地址和段的长度**。

**3.地址变换机构**
	系统中设置了**段表寄存器**，用于存放**段表始址和段表长度TL**。访址过程与分页访址过程类似。

**==4.分页和分段的主要区别==**
	①页是信息的**物理单位**。段是**信息的逻辑单位**，它**通常包含的是一组意义相对完整的信息**。
	②页的**大小固定且由系统决定**。段的**长度是不固定**的，决定于用户所编写的程序。
	③分页的用户地址空间是**一维**的。分段系统中，用户程序的地址空间是**二维**。

#### 信息共享

**1.分页系统中对程序和数据的共享**
	一个进程可能需要很多的页表项，设计多很多个页面。

**2.分段系统中的程序和数据的共享**
	由于以段未基本单位的额，不管该段有多大，我们都只需位该段设置一个段表项，因此实现变得非常容易。

可重入代码又称为“纯代码”，是一种允许多个进程同时访问的代码，不允许任何进程对它进行修改的代码。每个进程都**必须配以局部数据区**，把在**执行中可能改变的部分拷贝到数据区**，这样程序在执行时，**只需要对该数据区中的内容进行修改，并不去改变共享代码**。

#### 段页式存储管理方式

这种新的系统既具有分段系统的便于实现，分段可共享，易于保护，可动态链接等优点，又能像分段系统那样很好的解决内存的外部碎片问题。

**1.基本原理**
作业有**三个段**：主程序段，子程序段，数据段。
**地址结构：**段号，段内页号，子程序段和页内地址。
同时拥有**段表** 和 **页表**：段表的内容是**页表始址和页表长度**。

**2.地址变换过程**
	①由段号S和段表长度，得到自己在段表中的位置的页表，以及是否有越界。
	②由页号P和页表得到对应的物理块号b。
	③物理块号b  + 页内地址W则是实际的物理地址。

==【内部碎片】==
内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；
内部碎片 是处于 （操作系统分配的用于装载某一进程的内存）区域内部 或页面内部 的存储块。占有这些区域或页面的进程并不使用这个 存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。
单道连续分配只有内部碎片。 多道固定连续分配既有内部碎片，又有外部碎片。
==【外部碎片】==
外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。
外部碎片是处于任何两个已分配区域或页面之间的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。
