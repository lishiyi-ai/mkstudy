## 数据与文字的表示方法

#### 数据格式

**考虑因素**：①要表示的类型②可能的数值范围③数值精确度④数据存储和处理的所需要的硬件代价。

**1.定点数的表示方法**
	假设用**n + 1位**字来表示一个定点数x，其中**xn用来表示数的符号**，**其余**位数代表它的**量值**。
	如果数x表示的是**纯小数**，那么**小数点位于xn和xn-1之间**。范围为0到 1 - 2<sup>-n</sup>。
	如果数x表示的是**纯整数**，那么小数点位于最低位x0的右边。 范围为0到2<sup>n</sup>-1。

|  Xn  | Xn-1 Xn-2 ... X1 X2 |
| :--: | :-----------------: |

**2.浮点数的表示方法**

任意一个十进制数N可以写成：N = 10<sup>E</sup>.M。同样任意二进制数N可以写成：N = 2<sup>e</sup>.M

一般来说32位**8位阶码，23位尾数**；64位**11为阶码，52为尾数**。
32位：e = E - 127；64位：e = E - 1023 x =  (-1)<sup>S</sup> * (1.M) * 2<sup>E-1023</sup>

| Es(阶符) | Em-1...E1E0(阶码) | Ms(数符) | Mn-1...M1M2 |
| :------: | :---------------: | :------: | :---------: |

当尾数不为0时，尾数域的最高有效位应为1， 这成为浮点数的规格化。
在IEEE754标准中：x = (-1)<sup>S</sup> * (1.M) * 2<sup>E-127</sup>

对于32位浮点数N，**IEEE754定义**：
	①E = 255 且M<>0， 则N = NaN.
	②E = 255且M = 0，N = (-1)<sup>s</sup>∞.
	③E = 0且M = 0，N = (-1)<sup>s</sup>0.
	④若0 < E < 255，则N = (-1)<sup>S</sup> * (1.M) * 2<sup>E-127</sup> 范围10<sup>-38</sup>到10<sup>38.</sup>
	⑤若 E = 0且 M<>0，则N = (-1)<sup>S</sup> * (0.M) * 2<sup>-126</sup>.（非规格化数）

3.十进制数串的表示方法

​	①**字符串形式**：即1字节存放**一个**十进制的数位或符号位。(起始地址+位数(串长度))
​	②**压缩的十进制数串形式**：即1字节存放是**两个**十进制的数位。(首地址 + 数字位个数(不含符号位))

#### 数的机器码表示

**1.原码表示法**
	定点整数的原码形式为XnXn-1...X1X0；

**2.补码表示法**
	一个**正整数**，当用原码，反码，补码表示时，符号位都固定为0，二进制表示的**数位值都相同**。
	一个**负整数**，当原码、反码、补码表示时，符号位都固定为1，此时**原码表示法变成补码表示法的规则**如下：
		①原码符号不变，每位取反，得到反码
		②反码符号不变，反码数值位最低为加1，得到补码。

**3.移码表示法**
	假设定点整数移码形式位ek...e2e1(最高位为符号位时)，
	[e]移 = 2<sup>k</sup> + e (阶码是个k位的整数)，移码的符号位与前面相反。

**4.浮点数的机器表示**
	参见 2.浮点数表示。

#### 字符与字符串的表示方法
采用二进制格式的代码，来表示符号，如ASCII码。

#### 汉字表示方法

**1.汉字的输入编码** 输入
	**数字编码**：用数字串代表一个汉字输入。
	**拼音码**：以汉语拼音为基础的输入方法。
	**字形编码**：用汉字形状进行的编码。

**2.汉字内码** 内部处理
	用于汉字信息的存储、交换、检索等操作的**机内代码**，一般采用2字节表示。

**3.汉字字模码** 输出
	字模码使用点阵图表示的汉字字形代码，它是汉字的输出形式。

#### 校验码

计算机在**每个字上添加一些校验位**，用来确定字中出错的位置。计算机中常用这种**检错或纠错计数进行存储器读写正确性或传输信息的检验**。
最简单且最广泛的检错码是采用一位校验位的**奇校验**或**偶校验**。奇偶校验**提供奇数个错误检测**，**无法检测出偶数个错误**，更**无法识别错误的信息位置**。

## 定点加法、减法运算

#### 补码加法

​	**[X]补码 + [Y]补码 = [X + Y]补码**

#### 补码减法

​	**[X - Y]补码 = [X]补码 - [Y]补码 = [X]补码 + [-Y]补码**

#### 溢出概念与检测方法

**溢出**：在运算过程中如出现大于字长绝对值的现象，称为“溢出”。

**检测方法**：
	第一种方法：采用**双符号法**，称为“变形补码”
	第二种方法：采用单符号位法，当**最高有效位产生进位而符号位无进位**时，则正溢；当**最高有效位无进位而符号位有进位**，则负溢。

#### 基本的二进制加法器/减法器

n位的行波进位加减器：
	Ci+1的时间延迟位2T，T被定义为相应于单级逻辑电路的单位门延迟。T采用一个“与”门 或 一个“或”门的时间延迟作为度量单位。
	**==Ta = n*2T + 9T==**, 9T为最低两级异或门再加上溢出异或门的总时间。

## 定点乘法运算

**1.人工算法与机器算法的异同性**

人们能习惯的算法对机器并不完全适用：
	①机器通常只有n位长，两个n位相乘，乘积可能2n位
	②只有两个操作数相加的加法器，难以胜任将n个位积一次相加的运算。

**2.不带符号的阵列乘法器**

n位*n位不带符号的阵列乘法器总的乘法时间估算为：
	**Ta = T**为与门的传输延迟时间，**Tf = 2T**为全加器(FA)的进位传输延迟时间。
	**tm = Ta + (n - 1) * 6T（和输出的时间）+ (n-1) * Tf + 3T = ==(8n - 4)T==**

**3.带符号的阵列乘法器**

**延迟时间**：**==Ttc = n*2T + 5T==**

**计算公式**：**符号位 = xf ⊕ yf ，X*Y = X原码 * Y原码**

## 定点除法运算

#### 原码除法算法原理

**[q]原 = (xf  ⊕ yf) + (0.xn-1...x1x0 / 0.yn-1...y1y0)**

对于机器的运算过程：
	①不够减时必须恢复原来的余数，以便再继续往下运算，这种方法称为**恢复余数法**。
	②由于要恢复余数，使触发进行过程的步数不固定，因此控制比较福州，实际上运算中常用**加减交替法**。

#### 并行除法器

**1.可控 加法/减法 单元**

**==2.加减交替的阵列除法器==**	

## 定点运算器的组成

#### 逻辑运算

1.逻辑非运算 2.逻辑加运算(或) 3.逻辑乘运算(与) 4.逻辑异运算

#### 多功能算法/逻辑运算单元

行波进位加法器**存在的问题**：
	①由于串行进位，它的运算时间很长。
	②行波加法器本身来说，只能完成加法和减法两种操作而不能完成逻辑操作。

**先行进位加法器**：可以进行逻辑运算，算数运算，采用先行进位。

#### 内部总线

**总线分类**：
	①**内部总线**指CPU内部各部件的连线，②**外部总线**指CPU与存储器、I/O系统之间的连线。
	②**单项总线**，信息只能向一个方向传送，②**双向总线**，就是信息可以向两个方法传送。

#### 定点运算器的基本结构

**1.单总线结构**
	通用寄存器，专用寄存器，ALU连接在一条总线上。

**2.双总线结构**
	通用寄存器，专用寄存器，ALU连接在两条总线上。

**3.三总线结构**
	通用寄存器，专用寄存器，ALU连接在三条总线上。

## 浮点运算方法和浮点运算器

#### ==浮点加法、减法运算== 6

**①**0操作数检查
**②**比较阶码大小并完成对阶(小阶向大阶看齐)
**③**尾数加减运算
**④**结果规格化
**⑤**舍入处理
	就近舍入，朝0舍入，朝+∞舍入，朝-∞舍入。
**⑥**溢出处理
	**阶码上溢**：一般将其认为是正无穷 和 负无穷
	**阶码下溢**： 一般将其认为是0
	**尾数上溢**：同符号数相加产生了最高位进位，尾数右移
	**尾数下溢**：尾数右移时，尾数的最低有效位从尾数域右端流出，要进行舍入处理。

#### 浮点数乘法、除法运算

**运算规则**：
	x * y = 2<sup>Ex + Ey</sup> * (Mx * My)
	x / y = 2<sup>Ex - Ey</sup> * (Mx  / My)

**运算步骤**：6
①0操作数检查②阶码加/减操作③尾数乘/除操作④结果规格化⑤舍入处理⑥确定积的符号。

#### 浮点数运算流水线

**1.流水线原理**
	将任务分割成一系列可并行的子任务，使得多个任务同时执行时，可以划分成个每个子任务并行执行。
	**线性流水线的时钟周期**定义：Γ = max{Ti} + Tt(缓冲寄存器的延时)
	**时间周期**：**Tk = n-1 + k**
	串行时间周期：**Tl = n * k**
	**加速比**：**Ck = n * k / (K + n - 1)**

**2.流水线浮点加法器**
	将浮点加减法拆分成：①0操作数检查②对阶操作③尾数操作④结果规格化操作
