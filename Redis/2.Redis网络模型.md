## 阻塞IO

顾名思义，阻塞IO就是两个阶段都必须阻塞等待：
阶段一：
	①用户进程尝试读取数据（比如网卡数据）
	②此时**数据尚未到达**，内核需要等待数据
	③此时用户进程也处于阻塞状态
阶段二：
	①**数据到达并拷贝**到内核缓冲区，代表已就绪
	②将内核数据拷贝到用户缓冲区
	③拷贝过程中，用户进程依然阻塞等待
	④拷贝完成，用户进程解除阻塞，处理数据
可以看到，阻塞IO模型中，用户进程在两个阶段都是阻塞状态。

## 非阻塞IO

顾名思义，非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程。
阶段一：
	①用户进程尝试读取数据（比如网卡数据）
	②此时**数据尚未到达**，内核需要等待数据返回异常给用户
	③进程用户进程拿到error后，再次尝试读取
	④循环往复，直到数据就绪
阶段二：
	①将内核数据拷贝到用户缓冲区
	②拷贝过程中，用户进程依然阻塞等待
	③拷贝完成，用户进程解除阻塞，处理数据
可以看到，非阻塞IO模型中，用户进程在**第一个阶段是非阻塞，第二个阶段是阻塞状态**。**虽然是非阻塞，但性能并没有得到提高。**而且忙等机制会导致CPU空转，CPU使用率暴增。

## IO多路复用

**文件描述符**（File Descriptor）：简称FD，是一个从0 开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）。
**IO多路复用**：是利**用单个线程来同时监听多个FD**，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。
阶段一：
	①用户进程调用select，指定要监听的FD集合
	②内核监听FD对应的多个socket
	③任意一个或多个socket数据就绪则返回readable
	④此过程中用户进程阻塞
阶段二：
	①用户进程找到就绪的socket
	②依次调用recvfrom读取数据
	③内核将数据拷贝到用户空间
	④用户进程处理数据
**select和poll**只会通知用户进程有FD就绪，但不确定具体是哪个FD，需要用户进程逐个遍历FD来确认
**epoll**则会在通知用户进程FD就绪的同时，把已就绪的FD写入用户空间(通过回调函数实现**`file_operations->poll`**)

## 信号驱动IO

**信号驱动IO**是与内核建立**SIGIO的信号关联并设置回调**，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。

阶段一：
	①用户进程调用sigaction，**注册信号处理函数**
	②内核返回成功，开始监听FD
	③用户进程不阻塞等待，可以执行其它业务
	④当内核数据就绪后，回调用户进程的SIGIO处理函数
阶段二：
	①**收到SIGIO回调信号**
	②调用recvfrom，读取
	③内核将数据拷贝到用户空间
	④用户进程处理数据
当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出，而且内核空间与用户空间的频繁信号交互性能也较低。

## 异步IO

异步IO的整个过程都是非阻塞的，用户进程调用完异步API后就可以去做其它事情，内核等待数据就绪并拷贝到用户空间后才会递交信号，通知用户进程。
阶段一：
	①用户进程**调用aio_read**，创建信号回调函数
	②内核等待数据就绪
	③**用户进程无需阻塞**，可以做任何事情
阶段二：
	①内核数据就绪
	②内核数据拷贝到用户缓冲区
	③**拷贝完成，内核递交信号触发aio_read中的回调函数**
	④用户进程处理数据
可以看到，异步IO模型中，**用户进程在两个阶段都是非阻塞状态**。

![5种IO](E:\MarkDown_study\Redis\img\5种IO.png)

## Redis网络模型

**Redis到底是单线程还是多线程？**
	Redis的**核心业务部分**（命令处理），答案是**单线程**
	整个Redis，那么答案就是多线程
在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：
	Redis v4.0：引入多线程异步处理一些耗时较旧的任务，例如异步删除命令unlink
	Redis **v6.0**：在**核心网络模型中引入 多线程**，进一步提高对于多核CPU的利用率
因此，对于**Redis的核心网络模型**，在**Redis 6.0之前**确实都是单线程。是利**用epoll（Linux系统）这样的IO多路复用技术在事件循环中不断处理客户端情况**。

**为什么Redis要选择单线程？**
	抛开持久化不谈，**Redis是纯内存操作**，执行速度非常快，它的**性能瓶颈是网络延迟而**不是执行速度，因此多线程并不会带来巨大的性能提升。
	**多线程会导致过多的上下文切换**，带来不必要的开销。
	**引入多线程会面临线程安全问题**，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣。

