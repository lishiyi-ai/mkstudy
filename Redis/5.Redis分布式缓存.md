## 数据丢失问题(Redis持久化)

#### RDB持久化

RDB全称为**Redis Database Backup file(Redis数据备份文件)**，也叫**Redis数据快照**。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。

bgsave(避免主线程阻塞，save命令线程阻塞)开始时会fork主进程得到子进程，**子进程共享主进程的内存数据**。完成fork后读取内存数据并写入 RDB 文件。
fork采用的是**copy-on-write**技术：
	当**主进程执行读操作时，访问共享内存**；
	当**主进程执行写操作时，则会拷贝一份数据，执行写操作**。

#### AOF持久化

AOF全程为**Append Only File**(追加文件)。Redis处理的**每一个写命令都会记录在AOF文件中**，可以看作是命令日志文件。
因为是记录命令，**AOF文件会比RDB文件大的多**。而且**AOF会记录对同一个key的多次写操作**，但只有最后一次写操作才有意义。通过执行**bgrewriteaof命令**，可以让AOF文件**执行重写功能，用最少的命令达到相同效果**。

|                |                   **RDB**                    |                        **AOF**                         |
| :------------: | :------------------------------------------: | :----------------------------------------------------: |
|   持久化方式   |             定时对整个内存做快照             |                  记录每一次执行的命令                  |
|   数据完整性   |          不完整，两次备份之间会丢失          |                相对完整，取决于刷盘策略                |
|    文件大小    |             会有压缩，文件体积小             |                 记录命令，文件体积很大                 |
|  宕机恢复速度  |                     很快                     |                           慢                           |
| 数据恢复优先级 |          低，因为数据完整性不如AOF           |                 高，因为数据完整性更高                 |
|  系统资源占用  |            高，大量CPU和内存消耗             | 低，主要是磁盘IO资源但AOF重写时会占用大量CPU和内存资源 |
|    使用场景    | 可以容忍数分钟的数据丢失，追求更快的启动速度 |                对数据安全性要求较高常见                |

##### AOF三种回写策略

​	**Always**：总是，每次写操作命令执行完后，同步AOF会硬盘。
​	**Everysec**：每秒，先将命令写入AOF的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘。
​	**No**：交给操作系统控制回写的时机。

##### AOF重写机制

​	当AOF文件的大小超过所设定的阈值后，Redis就会启用AOF重写机制，来压缩AOF文件。

## 并发能力问题(Redis主从,读写分离)

单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要**搭建主从集群，实现读写分离**。

**全量同步的流程**：
	①slave节点请求增量同步(**slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave**)
	②master节点判断replid，发现不一致，拒绝增量同步
	③master将完整内存数据生成RDB，发送RDB到slave
	④slave清空本地数据，加载master的RDB
	⑤master将RDB期间的命令记录在repl_baklog(**有上限**)，并持续将log中的命令发送给slave
	⑥slave执行接收到的命令，保持与master之间的同步

可以从以下**几个方面来优化Redis主从就集群**：
	①在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。	
	②Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO。
	③适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步。
	④限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力。	

## 存储能力问题(Redis分片集群)

#### 分片集群结构

主从和哨兵可以解决**高可用**、**高并发读**的问题。但是依然有**两个问题**没有解决：
	**海量数据存储问题**
	**高并发写的问题**
使用分片集群可以解决上述问题，**分片集群特征**：
	集群中有**多个master**，每个master保存不同数据
	每个master都可以有多个slave节点
	**master之间通过ping监测彼此健康状态**
	客户端请求可以访问集群任意节点，最终都会被转发到正确节点

#### 散列插槽

Redis会把**每一个master节点映射到0~16383共16384个插槽**（hash slot）上，查看集群信息时就能看到：**数据key不是与节点绑定，而是与插槽绑定。**

#### 故障转移

## 故障恢复问题(Redis哨兵,健康检测和自动恢复)

#### 哨兵的作用和原理

**监控**：Sentinel(哨兵)会不断检查您的master和slave是否按预期工作。

**自动故障恢复**：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主。

**通知**：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新消息推送给Redis的客户端。

**服务状态监控**：Sentinel基于心跳机制检测服务状态，每1秒向集群的每个实例发送ping命令
	**主观下线**：sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。
	**客观下线**：超过指定数量的sentinel都认为该实例主观下线，则实例客观下线。

**选举新的master**：
一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：
	首先会判断slave节点与master节点**断开时间长短**，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点
	然后判断slave节点的**slave-priority值**，**越小优先级越高**，如果是**0则永不参与选举**
	如果slave-prority一样，则**判断slave节点的offset值**，**越大说明数据越新**，优先级越高
	最后是判断slave节点的**运行id大小，越小优先级越高**。	

#### RedisTemplate的哨兵模式

Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。