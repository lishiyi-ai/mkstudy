## 创建对象的过程

#### 1.分配内存空间

​	对于**全局对象**，**静态对象**以及**分配在栈区域内的对象**，对它们的**内存分配是在编译阶段就完成了**。

​	而对于**分配在堆区域内的对象**，它们的分配是**在程序运行阶段完成的**。

#### 2.初始化成员变量(初始化 和 赋值)

##### 初始化（Initialization）---------初始化列表实现

​	初始化 (Initialization)和赋值(Assignment)。**初始化早于赋值**，它是随着对象的诞生一起进行的。而赋值是在对象诞生以后又给予它一个新的值。对类对象的初始化，实际上是对类对象内的所有数据成员进行初始化。我们可以通过**实现构造函数的初始化列表(memberinitialization list)来实现**。

**初始化列表先于构造函数体内的代码执行；**

##### 赋值(Assignment)--------------构造函数函数体内赋值实现

​	对象经过初始化以后，我们仍然可以对其进行赋值。我们可以通过**构造函数的实现体**(即构造函数中由"{}"包裹的部分)来实现。**对象的初始化是通过初始化列表来完成**，**而对象的赋值则才是通过构造函数**，或者更准确的说应该是构造函数的实现体。

#### 3.调用构造方法

### 构造函数的使用

**•构造函数重载**
     –构造函数也是函数，拥有重载的特征
     –重载的构造函数在构造对象时根据参数自动选择

**•构造函数可以使用默认参数**
     –构造函数也拥有函数参数默认值的特性
     –使用默认值可以减少构造函数的个数

**•构造函数的初始化列表**
     –初始化列表可以让构造函数在被调用之前进行初始化工作
     –如果类的成员变量是const或引用类型，必须使用初始化列表初始化

## 构造函数的执行顺序

​	1.基类构造函数。如果有多个基类，则构造函数的调⽤顺序是某类在类派⽣表中出现的顺序，⽽不是它们在成员 初始化表中的顺序。 

​	2.成员类对象构造函数。如果有多个成员类对象则构造函数的调⽤顺序是对象在类中**被声明的顺序**，⽽不是它们 出现在成员初始化表中的顺序。 

​	3.派⽣类构造函数。

## 对象释放的过程

​	调用析构函数，对内存进行释放，但指针仍然指向内存卡，还需将指针悬空。

## 析构函数的执行顺序(与构造正好相反)

​	1.调⽤派⽣类的析构函数； 

​	2.调⽤成员类对象的析构函数； 

​	3.调⽤基类的析构函数。

## 什么时候需要用初始化列表

1.当初始化⼀个引⽤成员变量时； 

2.初始化⼀个 const 成员变量时； 

3.当调⽤⼀个基类的构造函数，⽽构造函数拥有⼀组参数时； 

4.当调⽤⼀个成员类的构造函数，⽽他拥有⼀组参数； 

5.编译器会⼀⼀操作初始化列表，以适当顺序在构造函数之内安插初始化操作，并且在任何显示⽤户代码前。list中 的项⽬顺序是由类中的成员声明顺序决定的，不是初始化列表中的排列顺序决定的。