## 双写缓冲区

![双写缓冲区](E:\MarkDown_study\数据库\img\双写缓冲区.png)

双写缓冲区是 InnoDB 引擎为了保证**数据安全性**，**完整性**而开发的
双写缓冲区是在**系统表空间**中：
	InnoDB 引擎会在磁盘上划分出连续的两个区的范围1个区包含64个页，一个页 16k，因此一个双写缓冲区大小为两个 1M ，共 2M。
	InnoDB 会先把数据从内存的双写缓冲区中，接着调用 fsync 写入到磁盘的双写缓冲区上（完整页数据），最后再把数据写入对应数据页中。

#### 为什么要用双写缓冲区？

​	首先**一页数据是 16 kb**，磁盘写一次是 4kb，因此**一页数据写磁盘，要写 4 次。**
​	假如在写的过程中出现数据库问题，就会导致**部分页写入问题**，**页的数据不完整，数据就会有问题**。而双写缓冲区作为一块预分配的磁盘位置，**数据库在写磁盘双写缓冲区时是使用的顺序写**，因此**效率**上要比直接写数据的随机写**快**的多，出问题的**概率小**。

#### fsync是什么？

​	为什么删除不会出现幻读 是底层操作系统对外提供的一个 API 接口，他能保证数据必然已经落盘。

#### 数据库突然出问题，双写缓冲区是如何恢复数据的？

​	会从磁盘的双写缓冲区中找到直接写入的完整的数据副本，再用这个完整的副本去对有问题的页数据进行恢复。**保证MySQL数据的原子性**。

#### 假如双写缓冲区出问题了呢？

​	MySQL 会根据磁盘上 B+ 树的结构，再配合上 Redo 日志对数据进行恢复。

#### 既然可以通过 Redo 日志进行恢复，那么为什么还要双写缓冲区？

​	MySQL 的 Redo 日志存储的是对页的物理操作，也就是**修改部分的操作，非修改部分的数据不保存**。如果破坏的是页中未修改的字段，那么就无法修复。

#### 双写缓冲区多一次写操作，对性能的影响大吗？

​	双写缓冲区的写操作是顺序写。经过测试，使用双写缓冲区与不使用相比，性能仅降低 5%-10%。

#### 事务还没提交的时候，redolog 能不能被持久化到磁盘呢？

InnoDB有一个**后台线程，每个1秒轮询一次**，这回导致没有提交的事务的redolog被持久化到磁盘。

innodb_flush_log_at_trx_commit 设置是 1，这样**并行的某个事务提交的时候，就会顺带将这个事务的 redolog buffer 持久化到磁盘。**

#### 既然双写缓冲区写要是失败了，需要 Redo 日志进行恢复，那么假如写 Redo 日志失败了怎么办？

​	不存在这种情况，因为每个事务在提交时都会将对应的 Redo 日志刷盘，只有 redo 日志刷盘成功了，事务才能算完成。

## AHI自适应哈希

在 InnoDB 存储引擎内部自己去监控索引表，如果**监控到某个索引经常用**，那么就认为是**热数据**，然后**内部自己创建一个 hash 索引**，称之为自适应哈希索引（Adaptive Hash Index，AHI）。
创建以后，如果**下次又查询到这个索引**， 那么**直接通过 hash 算法推导出记录的地址**，直接一次就能查到数据，比重复去 B+tree 索引中查询三四次节点的效率高了不少。
MySQL 在哈希索引的设计上还采用了**热点分散技术**，这样的哈希索引在 **MySQL 上默认是启动 8 个的**，热点数据会分散到不同的哈希索引上，因此热数据访问时，能**将请求分散到不同的哈希索引上**，提高了并发访问的性能。

## Buffer Pool

InnoDB 为了**缓存磁盘中的页**，在 MySQL 服务器启动的时候就向操作系统申请了一片连续的内存，叫做 **Buffer Pool**(默认128M)。
InnoDB 为每一个缓存页都创建了一些所谓的控制信息：

![Buffer Pool结构](E:\MarkDown_study\数据库\img\Buffer Pool结构.png)

#### Buffer Pool中的链表结构

**Free链表**
	把空闲的缓存页对应的控制块的地址用一个链表来维护

**Flush链** 
	结构与Free连完全一样。
	MySQL 把缓冲区上面这种**被修改过的数据的控制块**也用一个链表进行维护，以此来**快速定位被修改过的数据**，也被**称为脏数据**（未落盘的数据），因此 **Flush 链又被称为脏链**。	

**LRU链表**
	MySQL 就将**数据用一个 LRU 链表进行维护**，用来淘汰不常使用的数据，剩下的就是热门数据。
MySQL对LRU改进措施(避免预读失效)：
	1.将 LRU 链表分为两部分，前面为**热数据区**（Young 区），后面为**冷数据区**（Old 区），Old 区大小占 37%。
	**优点**：冷热链的切分，排除了全表扫描等类似的大数据量查询，直接把热门数据淘汰出缓冲区的情况。

​	2.对冷链数据移动到**热链上做了时间限定**。**限定时间内对冷链上数据的访问不会移动到热数据区**，只有超过这个时间，再次访问冷链上的数据，才会被移动到热数据区。
​	**优点**：避免了短时间内全表扫描等大数据量频繁刷新导致，热门数据被移出热链的情况。

​	3.热链的部分，**并非每次访问都会向前移动**。只有在**热点的后 1/4 内的数据**，在访问时才会移动到热链头部，减少移动带来的资源消耗，提升性能。

#### MySQL刷新落盘的途径

1.**BUF_FLUSH_LIST：**从 **flush 链表中刷新**一部分页面到磁盘

2.**BUF_FLUSH_LRU：**从 **LRU 链表的冷数据中刷新**一部分页面到磁盘

3.**BUF_FLUSH_SINGLE_PAGE：**用户线程在准备加载一个磁盘页到 Buffer Pool 时没有可用的缓存页，这时就会尝试看看 **LRU 链表尾部有没有可以直接释放掉的未修改页面**，如果没有的话会不得不**将 LRU 链表尾部的一个脏页同步刷新到磁盘**。

![数据库的存储结构总结](E:\MarkDown_study\数据库\img\数据库的存储结构总结.png)

#### 触发脏页的刷新：

①当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；

②Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；

③MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘；

④MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；
