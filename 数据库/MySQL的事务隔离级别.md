#### 事务的特性

原子性(undo log保证)，一致性(其他三个性质保证)，隔离性(**MVCC多版本并发控制**或锁机制保证)，持久性(redo log保证)。

#### 读未提交

指一个事务还没提交时，它做的变更就能被其他事务看到。
**遇到的问题**：如果一个事务[读到]了另一个[未提交事务修改过的数据]，就意味着发生了[**脏读**]现象。

#### 读提交

指一个事务提交之后，它做的变更才能被其他事务看到。
**遇到的问题**：在一个事务内多次读取动议数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了[**不可重复读**]现象。

#### 可重复读

指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**。

**遇到的问题**：在一个事务内多次查询某个符合查询条件的[记录数量]，如果出现**前后两次查询到的记录数量**不一样的情况，就意味着发生了[**幻读**]现象。

#### 串行化

会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

#### 幻读现象解决的方案(很大程度避免了幻读现象)

1.针对**快照读(select)**，通过MVCC方式解决了幻读，利用回滚日志的版本连，保证事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的。

2.针对**当前读(select ... for update)**，是通过next-key lock(记录锁 + 间隙锁)方式解决了幻读，当其它事务在next-key-lock锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入。

#### 提交读 和 可重复读 的底层原理

它们是通过**Read View**来实现的，它们的区别在于**创建Read View的时机不同**，[**读提交**]隔离级别是在**每个语句执行前都会重新生成**一个Read View，而[**可重复读**]隔离级别是[**启动事务时**]生成一个Read View，然后整个事务期间都在这个Read View

#### Read View如何工作

**creator_trx_id**：创建该事务ReadView的事务的**事务id**。

**m_ids**：创建Read View时，当前数据库中[活跃且未提交]的事务id列表。

**min_trx_id**：创建Read View当前数据库中活跃且未提交的事务中**最小事务的事务id**。

**max_trx_id**：创建Read View时当前数据库中应该**给下一个事务的id值**。

##### 可重复读如何工作

可重复读的事务在过程中，会顺着版本链找到**旧版本记录中trx_id小于**当前事务的**min_trx_id值**的第一条记录。
当前事务再次读取记录时，还是基于启动事务时创建的Read View来判断但其概念版本是否可见。

##### 可提交读如何工作

读提交隔离级别是在每次读取数据时，都会生成一个新的Read View。
当前事务每次在查找记录时，都会根据当前最小的min_trx_id来判断，找到第一个小于trx_id的记录并使用，因此会随着事务的提交而出现变化。

begin/start transaction命令(等到第一条select启动)

start transaction with consistent snapshot命令(立即启动)

#### MySQL可重复读隔离级别，完全解决了幻读吗？(没有)

**第一个发生幻读现象的场景**
	事务A查询的某一条记录不存在，事务B在查询后插入了一条这样的记录并提交事务，事务A对这条记录进行了修改，然后修改成功。这条记录的事务id由事务B变为了事务A的id。

**第二个发生幻读现象的场景**

T1时刻：事务A先执行[快照读语句]：得到了n记录。
T2时刻：事务B插入了一条记录并提交。
T3时刻：事务A在执行[当前读语句]就会得到n+1条记录。

