## 索引的分类

按**数据结构**分类：B+树索引，HASH索引，全文索引。

按**物理存储**分类：聚簇索引(主键索引)，二级索引(辅助索引)。

按**字段特性**分类：主键索引，唯一索引，普通索引，前缀索引(字符类型字段的前几个字符的索引)。

按**字段个数**分类：单列索引，联合索引(多个字段组合成一个索引，最左匹配原则)。

在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：
	如果**有主键**，默认会使用**主键作为聚簇索引的索引键**(key)；
	如果**没有主键**，就选择**第一个不包含 NULL 值的唯一列**作为聚簇索引的索引键(key)；
	在上面两个都没有的情况下，InnoDB 将**自动生成一个隐式自增 id** 列作为聚簇索引的索引键(key)；
	**创建的主键索引和二级索引默认使用的是 B+Tree 索引**。
**主键索引的 B+Tree** 和**二级索引的 B+Tree** **区别**如下：
	主键索引的 B+Tree 的**叶子节点存放的是实际数据**，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里。
	二级索引的 B+Tree 的**叶子节点存放的是主键值**，而不是实际数据。
**联合索引**
	联合索引的最左匹配原则，在遇到**范围查询（如 >、<）**的时候，就会**停止匹配**，**对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配**。

## 什么时候需要/不需要创建索引？

**使用的情况：**
	①字段有唯一性限制②常用于where查询条件的字段③常用于group by 和 order by字段**。**

**不需要创建索引的情况：**
	①用不到group by，order by②存在大量重复数据③表数据太少④经常更新的字段。

## 索引优化

1.**前缀索引优化**：使用某一个字段的前几个字符

2.**覆盖索引优化**：query的所有字段，在索引B+树的叶子节点上能找得到的那些索引**避免回表的操作**。

3.**主键索引最好是自增**

4.**索引最好设置为NOT NULL**

## ==B+树==

**B+树的优点**
***1、B+Tree vs B Tree***
	B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以B+Tree 的单个节点的数据量更小，在**相同的磁盘 I/O 次数下，就能查询更多的节点**。
	另外，B+Tree 叶子节点采用的是**双链表连接**，适合 MySQL 中**常见的基于范围的顺序查找**，而 B 树无法做到这一点。

***2、B+Tree vs 二叉树***
	对于有 N 个叶子节点的 B+Tree，其搜索复杂度为`O(logdN)`，其中 d 表示节点允许的最大子节点个数为 d 个。
	在实际的应用当中， d 值是大于1000的，这样就保证了，即使**数据达到千万级别时**，B+Tree 的**高度依然维持在 3~4 层左右**，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。

***3、B+Tree vs Hash***
	Hash 在做等值查询的时候效率贼快，**搜索复杂度为 O(1)**。
	但是 **Hash 表不适合做范围查询**，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。

## 索引失效

type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的**执行效率从低到高的顺序为：**
	All（全表扫描），index（全索引扫描），range（索引范围扫描），ref（非唯一索引扫描），eq_ref（唯一索引扫描），const（结果只有一条的主键或唯一索引扫描）

![索引总结](E:\MarkDown_study\数据库\img\索引总结.png)
